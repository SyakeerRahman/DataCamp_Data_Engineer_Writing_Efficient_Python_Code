# DataCamp_Data_Engineer_Writing_Efficient_Python_Code

Course Description<br />

As a Data Scientist, the majority of your time should be spent gleaning actionable insights from data -- not waiting for your code to finish running. Writing efficient Python code can help reduce runtime and save computational resources, ultimately freeing you up to do the things you love as a Data Scientist. In this course, you'll learn how to use Python's built-in data structures, functions, and modules to write cleaner, faster, and more efficient code. We'll explore how to time and profile code in order to find bottlenecks. Then, you'll practice eliminating these bottlenecks, and other bad design patterns, using Python's Standard Library, NumPy, and pandas. After completing this course, you'll have the necessary tools to start writing efficient Python code!

### 1. Foundations for efficiencies

In this chapter, you'll learn what it means to write efficient Python code. You'll explore Python's Standard Library, learn about NumPy arrays, and practice using some of Python's built-in tools. This chapter builds a foundation for the concepts covered ahead.

- [ ] Welcome!
- [ ] Pop quiz: what is efficient
- [ ] A taste of things to come
- [ ] Zen of Python
- [ ] Building with built-ins
- [ ] Built-in practice: range(
- [ ] Built-in practice: enumerate(
- [ ] Built-in practice: map(
- [ ] The power of NumPy arrays
- [ ] Practice with NumPy arrays
- [ ] Bringing it all together: Festivus!

### 2. Timing and profiling code

In this chapter, you will learn how to gather and compare runtimes between different coding approaches. You'll practice using the line_profiler and memory_profiler packages to profile your code base and spot bottlenecks. Then, you'll put your learnings to practice by replacing these bottlenecks with efficient Python code.

- [ ] Examining runtime
- [ ] Using %timeit: your turn!
- [ ] Using %timeit: specifying number of runs and loops
- [ ] Using %timeit: formal name or literal syntax
- [ ] Using cell magic mode (%%timeit)
- [ ] Code profiling for runtime
- [ ] Pop quiz: steps for using %|prun
- [ ] Using %lprun: spot bottlenecks
- [ ] Using %lprun: fix the bottleneck
- [ ] Code profiling for memory usage
- [ ] Pop quiz: steps for using %mprun
- [ ] Using %mprun: Hero BMI
- [ ] Using %mprun: Hero BMI 2.0
- [ ] Bringing it all together: Star Wars profiling

### 3. Gaining efficiencies

This chapter covers more complex efficiency tips and tricks. You'll learn a few useful built-in modules for writing efficient code and practice using set theory. You'll then learn about looping patterns in Python and how to make them more efficient.

- [ ] Efficiently combining, counting, and iterating
- [ ] Combining Pokémon names and types
- [ ] Counting Pokémon from a sample
- [ ] Combinations of Pokémon
- [ ] Set theory
- [ ] Comparing Pokédexes
- [ ] Searching for Pokémon
- [ ] Gathering unique Pokémon
- [ ] Eliminating loops
- [ ] Gathering Pokémon without a loop
- [ ] Pokémon totals and averages without a loop
- [ ] Writing better loops
- [ ] One-time calculation loop
- [ ] Holistic conversion loop
- [ ] Bringing it all together: Pokémon z-scores

### 4. Basic pandas optimizations

This chapter offers a brief introduction on how to efficiently work with pandas DataFrames. You'll learn the various options you have for iterating over a DataFrame. Then, you'll learn how to efficiently apply functions to data stored in a DataFrame.

- [ ] Intro to pandas DataFrame iteration
- [ ] Iterating with iterrows)
- [ ] Run differentials with iterrows)
- [ ] Another iterator method: itertuples)
- [ ] Iterating with itertuples)
- [ ] Run differentials with itertuples)
- [ ] pandas alternative to looping
- [ ] Analyzing baseball stats with .apply)
- [ ] Settle a debate with .apply
- [ ] Optimal pandas iterating
- [ ] Replacing iloc with underlying arrays
- [ ] Bringing it all together: Predict win percentage
- [ ] Congratulations!

